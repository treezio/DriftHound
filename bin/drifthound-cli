#!/usr/bin/env ruby
# frozen_string_literal: true
# encoding: utf-8

# drifthound-cli: Run Terraform/Terragrunt/OpenTofu, parse drift, and send to DriftHound API
require 'json'
require 'net/http'
require 'uri'

# Usage: drifthound-cli --tool=terraform --project=my-project --token=XXX --api-url=... [--dir=DIR] [--repository=URL] [--branch=BRANCH]
# Example: drifthound-cli --tool=terraform --project=my-project --token=XXX --api-url=http://localhost:3000 --dir=infra --repository=https://github.com/org/repo --branch=master
# Note: Repository URL and branch are auto-detected from git if not provided

require 'optparse'
opts = {}

OptionParser.new do |o|
  o.on('--tool=TOOL', 'terraform|terragrunt|opentofu') { |v| opts[:tool] = v }
  o.on('--project=KEY', 'Project key') { |v| opts[:project] = v }
  o.on('--environment=ENV', 'Environment key') { |v| opts[:environment] = v }
  o.on('--token=TOKEN', 'API token') { |v| opts[:token] = v }
  o.on('--api-url=URL', 'API base URL') { |v| opts[:api_url] = v }
  o.on('--dir=DIR', 'Working directory') { |v| opts[:dir] = v }
  o.on('--repository=URL', 'Repository URL (auto-detected from git if not provided)') { |v| opts[:repository] = v }
  o.on('--branch=BRANCH', 'Repository branch (auto-detected from git if not provided)') { |v| opts[:branch] = v }
  o.on('--slack-channel=CHANNEL', 'Slack channel for notifications (e.g., #drift-alerts)') { |v| opts[:slack_channel] = v }
end.parse!


abort('Missing --tool') unless opts[:tool]
abort('Missing --project') unless opts[:project]
abort('Missing --environment') unless opts[:environment]
abort('Missing --token') unless opts[:token]
abort('Missing --api-url') unless opts[:api_url]

dir = opts[:dir] || Dir.pwd

# Auto-detect repository URL from git if not provided
def detect_git_repository(dir)
  git_url = `git -C "#{dir}" remote get-url origin 2>/dev/null`.strip
  return nil if git_url.empty?

  # Convert SSH URLs to HTTPS
  # git@github.com:org/repo.git -> https://github.com/org/repo
  # ssh://git@github.com/org/repo.git -> https://github.com/org/repo
  if git_url =~ /^git@([^:]+):(.+)$/
    # git@github.com:org/repo.git format
    host = $1
    path = $2
    git_url = "https://#{host}/#{path}"
  elsif git_url.start_with?('ssh://git@')
    git_url = git_url.sub('ssh://git@', 'https://')
  end

  # Remove .git suffix
  git_url.sub(/\.git$/, '')
rescue
  nil
end

# Auto-detect branch from git if not provided
def detect_git_branch(dir)
  branch = `git -C "#{dir}" rev-parse --abbrev-ref HEAD 2>/dev/null`.strip
  return nil if branch.empty? || branch == 'HEAD'
  branch
rescue
  nil
end

# Auto-detect repository and branch if not provided
unless opts[:repository]
  detected_repo = detect_git_repository(dir)
  if detected_repo
    opts[:repository] = detected_repo
    puts "Auto-detected repository: #{detected_repo}"
  end
end

unless opts[:branch]
  detected_branch = detect_git_branch(dir)
  if detected_branch
    opts[:branch] = detected_branch
    puts "Auto-detected branch: #{detected_branch}"
  end
end

cmd = case opts[:tool]
when 'terraform', 'opentofu' then [ opts[:tool], 'plan', '-no-color', '-detailed-exitcode', '-lock=false' ]
when 'terragrunt' then [ 'terragrunt', 'plan', '-no-color', '-detailed-exitcode', '-lock=false' ]
else abort('Unknown tool')
end


puts "Running: #{cmd.join(' ')} in #{dir}"
start_time = Time.now
begin
  output = IO.popen(cmd, chdir: dir, err: [ :child, :out ]) { |io| io.read }
  output = output.force_encoding('UTF-8').scrub('?')
  exit_code = $?.exitstatus
rescue => e
  puts "Error running command: #{e.message}"
  output = "Error: #{e.message}"
  exit_code = 1
end
duration = Time.now - start_time
puts output
puts "Command exit code: #{exit_code}"
$stdout.flush

# Determine status from -detailed-exitcode
# Exit code 0 = no changes, 1 = error, 2 = changes detected (drift)
status = case exit_code
when 0 then 'ok'
when 2 then 'drift'
else 'error'
end
puts "Determined status: #{status}"

add_count = output[/ (\d+) to add/, 1]&.to_i || 0
change_count = output[/ (\d+) to change/, 1]&.to_i || 0
destroy_count = output[/ (\d+) to destroy/, 1]&.to_i || 0
puts "Counts - add: #{add_count}, change: #{change_count}, destroy: #{destroy_count}"

payload = {
  status: status,
  add_count: add_count,
  change_count: change_count,
  destroy_count: destroy_count,
  duration: duration,
  raw_output: output,
  directory: dir
}

# Add repository if provided
payload[:repository] = opts[:repository] if opts[:repository]

# Add branch if provided
payload[:branch] = opts[:branch] if opts[:branch]

# Add notification channel configuration if provided
if opts[:slack_channel]
  payload[:notification_channel] = {
    channel_type: 'slack',
    enabled: true,
    config: {
      channel: opts[:slack_channel]
    }
  }
end

puts "Building API request..."
uri = URI("#{opts[:api_url]}/api/v1/projects/#{opts[:project]}/environments/#{opts[:environment]}/checks")
puts "Sending drift report to #{uri}..."
$stdout.flush

begin
  req = Net::HTTP::Post.new(uri)
  req['Authorization'] = "Bearer #{opts[:token]}"
  req['Content-Type'] = 'application/json'
  req.body = payload.to_json

  res = Net::HTTP.start(uri.hostname, uri.port, use_ssl: uri.scheme == 'https') { |http| http.request(req) }
  puts "Response: #{res.code} #{res.body}"
rescue => e
  puts "Error sending API request: #{e.class} - #{e.message}"
  exit 1
end

exit(res.code.to_i >= 400 ? 1 : 0)
