#!/usr/bin/env ruby
# frozen_string_literal: true
# encoding: utf-8

# drifthound-cli: Run Terraform/Terragrunt/OpenTofu, parse drift, and send to DriftHound API
require 'json'
require 'net/http'
require 'uri'

# Usage: drifthound-cli --tool=terraform --project=my-project --token=XXX --api-url=... [--dir=DIR]
# Example: drifthound-cli --tool=terraform --project=my-project --token=XXX --api-url=http://localhost:3000 --dir=infra

require 'optparse'
opts = {}

OptionParser.new do |o|
  o.on('--tool=TOOL', 'terraform|terragrunt|opentofu') { |v| opts[:tool] = v }
  o.on('--project=KEY', 'Project key') { |v| opts[:project] = v }
  o.on('--environment=ENV', 'Environment key') { |v| opts[:environment] = v }
  o.on('--token=TOKEN', 'API token') { |v| opts[:token] = v }
  o.on('--api-url=URL', 'API base URL') { |v| opts[:api_url] = v }
  o.on('--dir=DIR', 'Working directory') { |v| opts[:dir] = v }
  o.on('--slack-channel=CHANNEL', 'Slack channel for notifications (e.g., #drift-alerts)') { |v| opts[:slack_channel] = v }
end.parse!


abort('Missing --tool') unless opts[:tool]
abort('Missing --project') unless opts[:project]
abort('Missing --environment') unless opts[:environment]
abort('Missing --token') unless opts[:token]
abort('Missing --api-url') unless opts[:api_url]

dir = opts[:dir] || Dir.pwd
cmd = case opts[:tool]
when 'terraform', 'opentofu' then [ opts[:tool], 'plan', '-no-color', '-detailed-exitcode' ]
when 'terragrunt' then [ 'terragrunt', 'plan', '-no-color', '-detailed-exitcode' ]
else abort('Unknown tool')
end


puts "Running: #{cmd.join(' ')} in #{dir}"
start_time = Time.now
begin
  output = IO.popen(cmd, chdir: dir, err: [ :child, :out ]) { |io| io.read }
  output = output.encode('UTF-8', invalid: :replace, undef: :replace, replace: '?')
  exit_code = $?.exitstatus
rescue => e
  puts "Error running command: #{e.message}"
  output = "Error: #{e.message}"
  exit_code = 1
end
duration = Time.now - start_time
puts output
puts "Command exit code: #{exit_code}"
$stdout.flush

# Determine status from -detailed-exitcode
# Exit code 0 = no changes, 1 = error, 2 = changes detected (drift)
status = case exit_code
         when 0 then 'ok'
         when 2 then 'drift'
         else 'error'
         end
puts "Determined status: #{status}"

add_count = output[/ (\d+) to add/, 1]&.to_i || 0
change_count = output[/ (\d+) to change/, 1]&.to_i || 0
destroy_count = output[/ (\d+) to destroy/, 1]&.to_i || 0
puts "Counts - add: #{add_count}, change: #{change_count}, destroy: #{destroy_count}"

payload = {
  status: status,
  add_count: add_count,
  change_count: change_count,
  destroy_count: destroy_count,
  duration: duration,
  raw_output: output
}

# Add notification channel configuration if provided
if opts[:slack_channel]
  payload[:notification_channel] = {
    channel_type: 'slack',
    enabled: true,
    config: {
      channel: opts[:slack_channel]
    }
  }
end

puts "Building API request..."
uri = URI("#{opts[:api_url]}/api/v1/projects/#{opts[:project]}/environments/#{opts[:environment]}/checks")
puts "Sending drift report to #{uri}..."
$stdout.flush

begin
  req = Net::HTTP::Post.new(uri)
  req['Authorization'] = "Bearer #{opts[:token]}"
  req['Content-Type'] = 'application/json'
  req.body = payload.to_json

  res = Net::HTTP.start(uri.hostname, uri.port, use_ssl: uri.scheme == 'https') { |http| http.request(req) }
  puts "Response: #{res.code} #{res.body}"
rescue => e
  puts "Error sending API request: #{e.class} - #{e.message}"
  exit 1
end

exit(res.code.to_i >= 400 ? 1 : 0)
